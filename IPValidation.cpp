#include <iostream>
#include <cmath>

// Задание 3. Валидация IP-адреса. Что нужно сделать. Проверьте, задаёт ли введённая пользователем строка корректный IP-адрес четвёртой версии (IPv4). IP-адрес должен представлять из себя четыре числа, разделённые точками без пробелов, причём каждое число должно быть в диапазоне от 0 до 255 включительно. Числа не должны содержать ведущих нулей. Других символов в строке, кроме вышеописанных, быть не должно. Пользователь вводит строку, задающую IP-адрес через стандартный ввод. В результате программа должна вывести слово Valid, если адрес корректен, и слово Invalid, если это не так. Примеры.

/*Корректные: 
127.0.0.1 
255.255.255.255 
1.2.3.4 
55.77.213.101

Некорректные: 
255.256.257.258 (есть числа больше 255) 
0.55.33.22. (лишняя точка в конце) 
10.00.000.0 (лишние нули) 
23.055.255.033 (опять лишние нули) 
65.123..9 (две точки подряд) 
a.b.c.d (посторонние символы вместо чисел и точек)*/

// Рекомендации. Активно используйте оператор индексации строки str[i], но помните, что индексы начинаются с нуля, а не с единицы. Создайте отдельную функцию для получения отдельных чисел из IP-адреса и валидируйте эти отдельные числа. Для валидации отдельных цифр у чисел следует использовать оператор сравнения с константами символов. Символы от ‘0’ до ‘9’ расположены последовательно и поэтому уместны операторы <= и >=. Вам потребуется функция, принимающая на вход строку со всем IP-адресом и порядковый номер октета. Октет — это часть IP-адреса между точками. Он содержится в восьми битах, отсюда и название (окта — восемь). 2^8 = 256. Отсюда уже предел значения октета — 255. То есть вызов get_address_part(“192.168.1.1”, 1) вернёт 168. Данная функция проходит по всей строке и ищет разделители — точки, одновременно с этим накапливает символы в строку, которую вернёт в результате. При нахождении разделителя нужно вернуть полученную строку. Проверку её корректности нужно делать в другой функции (проверить длину == 3 и то, что число в строке находится в диапазоне [0,255] ). Что оценивается. Корректность валидации заданного пользователем адреса.

std::string get_address_part(std::string address, int part) 
{
    std::string address_part = "";
    int counter = 0;
    for (int i = 0; i < address.length(); i++)
    {
        if ((address[i] >='0') && (address[i] <= '9')) 
        {
            if (counter == part) address_part += address[i];
        }
        else if (address[i] == '.') 
        {
            counter++;
        }
        else
        {
            return "";
        }
    }
    return (counter == 3)? address_part : "";
}

bool address_part_check(std::string address_part) 
{
    if (address_part.length() == 0 || (address_part[0] == '0' && address_part.length() > 1)) return false;
    int num = 0;
    for (int i = 0; i < address_part.length(); i++)
    {
        num += ((int) (address_part[i] - '0')) * std::pow(10, (address_part.length() - (i + 1)));
    }
    // std::cout << num << std::endl;
    return (num < 256)? true : false;
}

int main() 
{
    std::string address;

    while (true)
    {
        address = "";
        std::cout << "Enter IP address or 'q' to exit: ";
        std::cin >> address;

        if (address == "q")
        {
            std::cout << "See you again!" << std::endl;
            return 0;
        }

        bool valid_address = true;
        for (int i = 0; i < 4; i++)
        {
            if (!address_part_check(get_address_part(address, i))) 
            {
                valid_address = false;
                break;
            }
        }
        std::cout << ((valid_address)? "Valid.\n" : "Invalid.\n");
    }
}
