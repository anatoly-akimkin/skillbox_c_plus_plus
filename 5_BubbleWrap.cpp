// Задание 5. Пупырка. После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. Всего в пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый, либо нет, то есть true или false (тип массива — bool). Для начала требуется реализовать отдельную функцию инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true. Программа заключается в последовательном лопании целых регионов пузырьков. Перед каждым таким лопанием надо показывать пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию. Итак, как выглядит само лопание. Пользователь вводит две координаты: начала региона и конца региона. Процедура лопания пузырей должна быть реализована с помощью отдельной функции, все аргументы должны проверяться на валидность, что они в в рамках диапазона возможных значений, иначе должна быть выведена ошибка. После лопания каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться сообщение “Pop!”. Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает выполнение. Вы можете подсчитать окончание в самой функции по отображению пузырьков плёнки, так как функция выполняется после каждого лопания.
// Советы и рекомендации. Обратите внимание, что лопание пузырей делается с помощью региона, а не одной точки. Регион задаётся двумя координатами, это координаты углов прямоугольника. При лопании региона достаточно запустить цикл только по этим элементам. Не нужно проходить каждый раз по всей матрице. Всю область плёнки удобно представить в виде двумерного массива типа bool. Инициализировать вручную такой массив сложно, лучше воспользоваться вложенными циклами. Для проверки на целостность одной ячейки (если вы используете тип bool) можно не сравнивать её с истиной, а указать в условии имя переменной. Например, вместо:
/*if (shell[i][j] == true)
{
  …
}
Достаточно записать:
if (shell[i][j])
{
  …
}
Такой трюк можно проделывать с переменными типа bool.*/
// Что оценивается. Программа заканчивает выполнение только после того, как не осталось целых пузырей. Лопание пузырей производится с помощью прямоугольной области.

#include <iostream>
#include <limits>

void initialize_matrix(bool matrix[][12])
{
    int val;
    for (int i = 0; i < 12; i++)
    {
        for (int j = 0; j < 12; j++)
        {
            matrix[i][j] = true;
        }
    }
}

bool print_matrix(bool matrix[][12])
{
    bool bubbles = false;
    std::cout << std::endl;
    for (int i = 0; i < 12; i++)
    {
        for (int j = 0; j < 12; j++)
        {
            if (matrix[i][j])
            {
                std::cout << "O  ";
                bubbles = true;
            }
            else
            {
                std::cout << "X  ";
            }
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    return bubbles;
}

int input_val()
{
    int val;
    while (true)
    {
        std::cin >> val;
        if (std::cin.fail())
        {
            std::cerr << "Integer input expected.\n";
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), ' ');
            continue;
        }
        if (val >= 0 && val < 12) return val;
        std::cout << "The value is out of array bounds.\n";
    }
}

void burst(bool m[][12])
{
    int x1, x2, y1, y2;
    std::cout << "Enter the coordinates of the affected area.\n";
    std::cout << "From - To:\n";
    x1 = input_val();
    y1 = input_val();
    x2 = input_val();
    y2 = input_val();
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    if (x2 < x1) std::swap(x1, x2);
    if (y2 < y1) std::swap(y1, y2);

    int count = 0;
    for (int i = y1; i < (y2 + 1); i++)
    {
        for (int j = x1; j < (x2 + 1); j++)
        {
            if (m[i][j]) 
            {
                if (count % 10 == 0) std::cout << std::endl;
                count++;
                std::cout << "Pop! ";
                m[i][j] = false;
            }
        }
    }
    std::cout << std::endl;
}

int main()
{
    bool bubble_wrap[12][12];
    initialize_matrix(bubble_wrap);
    while (print_matrix(bubble_wrap)) burst(bubble_wrap);
    std::cout << "All the bubbles have burst.";
}