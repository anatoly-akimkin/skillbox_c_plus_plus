// Задание 2. Крестики-нолики. Что нужно сделать. Старая добрая игра на страницах всех школьных тетрадей. Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char. Участвуют два игрока, они ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ — X или O (буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика, он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено, то объявляется ничья. Для простоты не будем рассматривать диагональные совпадения — только строго вертикальные и строго горизонтальные.
// Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения пробела кавычки одинарные и в одну сторону). Это можно сделать сразу при объявлении либо с помощью вложенного цикла. На каждом ходе при занятой клетке или при неверных координатах этой клетки должно быть выведено сообщение, и игрок должен указать координаты клетки повторно. После каждого хода надо выводить в консоль текущее состояние всего игрового поля для наглядности.
// Советы и рекомендации. Действия для обоих игроков одинаковые, отличаются только символом, который ставится на поле. Игровой цикл не должен быть бесконечным. Игра имеет определённое максимальное количество шагов. Не забывайте про случай ничьей. Как и в предыдущем задании, здесь будет удобно сразу заполнить массив значениями false. Количество мест, доступных для заполнения, заранее известно. В процессе заполнения из этой переменой нужно не забывать вычитать единицу. Чтобы отметить место как занятое, нужно лишь написать places[i][j] = true;. Проверку на победу игрока, которую надо осуществлять после каждого хода, можно сделать с помощью вложенного цикла, сразу проверяя и вертикаль, и горизонталь, а как именно — попробуйте догадаться сами. Здесь заранее известно число ходов — 3 * 3. Столько раз должен быть выполнен цикл, который спрашивает у очередного игрока координаты. Символ, который будет установлен в указанных координатах, можно на каждом шаге менять подобным образом:
/*if (gamer_name == 'X') 
                gamer_name = 'O'; 
else 
                gamer_name = 'X';*/
// Что оценивается. Корректный ход игры, соответствующий правилам. Правильный (желательно красивый) вывод игрового поля. Понятный игроку интерфейс.

#include <iostream>
#include <limits>

void print_matrix(char matrix[][3])
{
    std::cout << std::endl;
    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            if (i%2 == 0)
            {
                if (j%2 == 0)
                {
                    std::cout << ' ' << matrix[i/2][j/2] << ' ';
                }
                else
                {
                    std::cout << "|";
                }
            }
            else
            {
                if (j%2 == 0)
                {
                    std::cout << "---";
                }
                else
                {
                    std::cout << "+";
                }
            }
        }
        std::cout << std::endl;
    }
}

int input_val()
{
    while(true)
    {
        int val;
        std::cin >> val;
                
        if (std::cin.fail())
        {
            std::cerr << "Integer input expected.\n";
            std::cin.clear();
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), ' ');
            continue;
        }

        if (val >= 0 && val < 3) return val;
        std::cout << "Invalid value!\n";
    }
}

bool find_matches(char c, char m[][3], int x, int y)
{
    int v_matches = 0, h_matches = 0;
    for (int j = 0; j < 3; j++)
    {
        if (m[y][j] == c) h_matches++;
        if (m[j][x] == c) v_matches++;
    }
    if (v_matches == 3 || h_matches == 3 || // Vertical or horizontal
       (x == y && m[0][0] == m[1][1] && m[2][2] == m[1][1]) || //  '\' Diagonal
       (x + y == 2 && m[0][2] == m[1][1] && m[2][0] == m[1][1])) //  '/' Diagonal
    {
        return true;
    }
    return false;
}

int main()
{
    char field[3][3] {{' ', ' ', ' '}, 
                      {' ', ' ', ' '}, 
                      {' ', ' ', ' '}};
    print_matrix(field);
    char gamer_name = 'O';
    
    for (int i = 0; i < 9; i++)
    {
        gamer_name = (gamer_name == 'X')? 'O' : 'X';
        int a, b;
        bool invalidVal = true;

        do
        {
            std::cout << std::endl << gamer_name << ": ";
            a = input_val();
            b = input_val();
            
            if (field[b][a] == ' ') 
            {
                invalidVal = false;
            }
            else
            {
                std::cout << "The square is occupied!\n";
            }
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        } 
        while(invalidVal);
        
        field[b][a] = gamer_name;
        print_matrix(field);
        
        if (find_matches(gamer_name, field, a, b)) 
        {
            std::cout << std::endl << gamer_name << " is a winner!";
            return 0;
        }
    }

    std::cout << "\nIt's a draw!";
}